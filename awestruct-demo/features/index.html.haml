---
layout: base
title: Feature Tour
description: A tour of the features that enable you to write real integration tests
body_class: tour
---
#main
  #content-header
    .container
      %h1= page.title
  .container 
    #content.features
      .feature
        .summary
          %h2 Real Tests
          %p Mocks can be tactical, but more often than not, they are used to make code work outside of a real environment. Arquillian lets you ditch the mocks and write real tests. That's because Arquillian brings your test to the runtime, giving you access to container resources, meaningful feedback and insight about how the code <em>really</em> works.
          %p.learn
            %a(href='/guides/getting_started/#a_closer_look') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_real_tests.png' style='border: 1px solid #f0f0f0')
      %hr
      .feature
        .summary
          %h2 IDE Friendly
          %p The learning curve for getting started with Arquillian is minimized by the fact that it integrates with what you already know. Using JUnit for your unit tests? Then you can reuse your knowledge of JUnit to do integration testing. TestNG? Arquillian lets you choose. And you can even run your Arquillian tests right alongside unit tests in your IDE.
          %p.learn
            %a(href='/guides/getting_started/#run_the_arquillian_test') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_ide_friendly.png')
      %hr
      .feature
        .summary
          %h2 Test Enrichment
          %p Your application and tests can share the same programming model, regardless of technology stack. For example, Arquillian can inject the deployed Contexts and Dependency Injection (CDI) beans, Enterprise JavaBeans (EJB) components and other Java EE resources directly to your tests. Arquillian can also extend that programming model to provide access to container APIs and implicit objects from test frameworks such as JSFUnit and Selenium.
          %p.learn
            %a(href='/guides/getting_started/#a_closer_look') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_enrich.png')
      %hr
      .feature
        .summary
          %h2 Classpath Control
          %p Most test suites are a mess, but it's not your fault. Test frameworks carelessly use whatever classes and resources are on the classpath of the test, making isolation of the test scenario difficult and turning the test suite into a Frankenstein. Not Arquillian. Micro-deployments are much smaller than the full application, so the test archive deploys faster, which means you get a faster test-code-test development cycle.
          %p.learn
            %a(href='/guides/getting_started/#write_an_arquillian_test') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_microdep.png')
      %hr
      .feature
        .summary
          %h2 Drive the Browser
          %p Arquillian is just as relevant for client testing as it is for server-side testing. Arquillian Drone abstracts away all the tedious setup of the Selenium Server, letting you skip right to driving the browser from your test. Arquillian even unifies client and server-side testing, most apparent in our JSFUnit integration.
          %p.learn
            %a(href='/guides/functional_testing_using_graphene') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_browser.png')
      %hr
      .feature
        .summary
          %h2 Debug the Server
          %p Arquillian brings you server-side debugging like never before. Typically, you have to package the application, deploy it to the server, connect the debugger and interact with the UI in order to hit the breakpoint. Now you can just drop a breakpoint in the test or application code and debug the test. <em>Bang</em>, you hit the breakpoint inside the server from the comfort of your IDE. <em>Prepare for an eye opening experience!</em>
          %p.learn
            %a(href='/guides/getting_started/#debug_the_test') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_debug.png')
      %hr
      .feature
        .summary
          %h2 Container Agnostic
          %p You name the container, Arquillian can manage it. <em>If not, why not write an adapter?</em> Having the choice of multiple containers allows you to switch from an embedded container in development to a standalone server for continuous integration, test on different compliant containers to ensure application portability, or even interact with several containers in the same test to validate distributed behavior.
          %p.learn
            %a(href='/guides/getting_started/#add_more_containers') Learn to use this feature &raquo;
        .preview
          %img(src='/images/feature_env.png')
      %hr
      .feature
        .summary
          %h2 Extensible Platform
          %p There's no limit to what you can test using Arquillian. Many extensions are available. If you're looking for an integration that's not yet implemented, Arquillian provides an extensible platform into which you can integrate that next great testing tool.
        .preview
          %img(src='/images/feature_extend.png')
      %hr
      .feature
        .preview
          %h2 Strong Tooling
          %p Want to take the quick path to getting started with Arquillian? Tools like JBoss Forge can help. Just install the Arquillian plugin, set it up in your project, and get started writing tests in seconds. You'll be amazed how easy it is to get started with Arquillian and Forge - it's the next enterprise evolution.
          %p.learn
            %a(href='/guides/get_started_faster_with_forge') Learn to use this feature &raquo;
        .summary
          %img(src='/images/feature_tools.png')
      %hr
      %p.rally
        %strong Death to all bugs!
